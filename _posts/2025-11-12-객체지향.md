---
layout: post
title: "객체지향"
date:   2025-11-12 17:51:00 +0900
categories: [blog, GitHub]
---

## 잘못된 객체지향: 버그의 온상

많은 객체지향 입문서와 강의는 캡슐화, 상속, 다형성, 추상화 같은 네 가지 원칙과 SOLID 원칙을 중심축으로 설명한다.
그러나 처음 이를 접하는 사람들에게—특히 클래스의 역할조차 명확히 이해하지 못한 상태에서는—이 원칙들은 너무 추상적이다.
‘좋은 설계 원칙’이라는데, 막상 코드에 적용하려면 Animal–Cat 예시 이상의 감이 잡히지 않는다.

나 또한 그랬다. 한때는 SOLID 다섯 글자를 외우며 “디자인 패턴을 모르면 좋은 프로그래머가 될 수 없다”고 믿었다.
하지만 원칙을 억지로 끼워 맞추던 시절엔, 기준이 모호하고 방향을 잡기 어려웠다.
‘교과서에 적혀 있으니 이렇게 써야 하나?’ 하며 어딘가 안 맞는 퍼즐을 억지로 끼워 넣듯 코드를 짜곤 했다.

실무에 처음 객체지향을 적용했을 때는 더 막막했다.
“상속은 왜 필요한가?”, “이 구조에서 캡슐화는 무슨 의미인가?”—단 하나의 함수조차 설계하기 어려운데, 클래스를 잘 설계할 리가 없었다.
결국 만들어진 것은 ‘누더기 골렘’ 같은 코드베이스였다.
한 곳을 고치면 다른 곳이 깨지고, 익셉션은 꼬리에 꼬리를 물었다.
버그의 근원은 문법이 아니라 **‘객체의 상태를 이해하지 못한 채 구조만 모방한 객체지향’**이었다.

## 객체지향의 본질 Chapter1: 상태

여러 시행착오 끝에, 나는 근본적인 질문으로 돌아갔다.
“객체지향이란 도대체 무엇인가?”

놀랍게도 답은 클래스조차 존재하지 않는 언어들—C와 Go에서 찾아졌다.
이 두 언어는 오직 데이터(struct) 와 그 데이터를 다루는 함수(function) 로 모든 기능을 구성한다.
즉, 데이터와 그 변화를 다루는 행위, 그것이 객체지향의 본질이라는 점이 드러났다.

C 레벨로 내려가면 클래스와 구조체의 차이는 거의 없다.
구조체에 함수 포인터를 추가하면 그것이 바로 메서드이며, 결국 **class란 ‘데이터 + 그 데이터를 다루는 함수의 묶음’**일 뿐이다.
CPU 입장에서는 둘 다 동일한 메모리 구조를 가진다.

이 관점에서 보면 객체지향의 핵심은 “상속”도 “캡슐화”도 아닌, **‘멤버변수들의 상태를 어떻게 일관성 있게 유지하느냐’**다.
모든 클래스는 일정한 초기 상태를 정의해야 하며, 그 상태의 변화를 명시적이고 예측 가능한 방식으로 관리해야 한다.
그것이 객체의 책임이자, 객체지향의 출발점이다.

### 상태의 불안정성

잘못 관리되는 상태는 본질적으로 불안정하다.
객체가 불안정하다는 것은 곧 그 내부 데이터가 신뢰할 수 없다는 것이며,
이는 단일 객체의 문제에 그치지 않고 시스템 전체의 버그로 확산된다.

객체의 상태는 프로그램이 실행되는 동안 수많은 연산과 상호작용을 거친다.
그 과정에서 한 번이라도 의도하지 않은 값이나 모호한 타입이 들어가면,
그 객체는 더 이상 “예측 가능한 동작”을 하지 못한다.
이때부터 모든 계산, 모든 로직은 불확실성 위에 서 있게 된다.

관리되지 않은 상태는 다음과 같은 경우를 의미한다.
- 객체가 유효하지 않은 초기 상태를 가질 때
- 멤버 변수의 타입이 일관되지 않을 때
- 외부에서 명시적이지 않은 방식으로 내부 값을 조작할 때

#### 유효하지 않은 초기값을 경계하라.

객체는 반드시 그 생성시점이 제일 중요하다.
이 시점부터 그 객체의 불안정성이 결정된다.

```python

# 유효하지 않은 초기값을 허용하는 클래스
class BadClass:
    def __init__(self, foo, bar) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    b = BadClass(1, 2)                      # 비정상, 타입 불일치

```
이 클래스는 한눈에 보기엔 단순하지만, 객체의 “의미적 상태”가 완전히 무너져 있다.
a와 b는 동일한 클래스에서 생성되었지만, 전혀 다른 타입을 가진다.
get_foo_length()를 호출하면 a는 정상 동작하지만 b는 TypeError를 발생시킨다.
즉, 같은 클래스의 인스턴스가 동일한 연산에 대해 일관된 결과를 보장하지 못하는 상태, 이것이 바로 **‘불안정한 객체’**다.

> 객체의 초기화 시점에 유효한 검증이 없다면, 클래스 설계는 실패한 것이다.

#### 멤버 변수의 타입은 생애주기 전체에서 일관되어야 한다.

안정적인 객체는 반드시 그 소멸까지 동일한 타입을 유지해야한다.
```python

# 유효하지 않은 초기값을 허용하는 클래스
class BadClass:
    def __init__(self, foo: str, bar: str) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

    def set_foo(self, v):
        self.foo = v

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    a.set_foo(4)                            # 타입 변경
    a.get_foo_length()                      # TypeError 발생

```
이 코드는 초기에는 문제가 없어 보이지만,
set_foo()에서 타입 일관성이 깨지면서 런타임 버그가 발생한다.

이 문제는 파이썬처럼 동적 타입 언어에서 특히 흔하다.
프로그램은 실행 중에 수없이 많은 곳에서 set_foo()를 호출할 수 있고,
그중 단 한 번만 타입이 잘못 들어가도 객체 전체가 오염된다.

#### 명시적인 인터페이스를 통해서만 상태를 조작하라.

가장 흔하지만 치명적인 버그유발점은 직접 속성 접근이다.
```python
class BadClass:
    def __init__(self, foo: str, bar: str) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    a.foo = 4
    a.get_foo_length() # 버그 발생
```
파이썬에서는 이런 직접 접근을 “간단하고 직관적이다” 라고 여길 수 있다.
하지만 이는 곧 객체의 내부 계약을 깨뜨리는 위험한 행위다.
외부에서 임의로 값을 변경하면, 클래스 내부에서 정의한 모든 전제가 깨진다.

이 문제를 해결하려면,
모든 상태 변경은 반드시 명시적 인터페이스(Setter 메서드) 를 통해 이뤄져야 한다.

> “캡슐화(Encapsulation)”란 데이터를 숨기는 것이 아니라, 데이터 변경 경로를 통제하는 것이다.

### 상속의 숨겨진 위험

객체지향을 처음 배울 때, 그 세 번째 기둥으로 강조되는 개념이 바로 상속(Inheritance) 이다.
“기존 코드를 재활용할 수 있다”는 약속은 달콤하게 들리지만,
실제 현업에서는 이 단어만큼 많은 시스템을 병들게 한 개념도 드물다.
상속은 잘못 사용되면 결합도(coupling) 를 폭발적으로 높이고,
객체의 상태를 통제 불가능하게 만든다.

#### 강한 결합도의 함정

상속은 단순한 코드 재사용 메커니즘이 아니다.
상속은 부모 클래스의 구현 세부사항을 자식이 전적으로 신뢰한다는 의미이며,
이는 곧 부모의 모든 변경이 자식에게 직접적인 영향을 미친다는 뜻이다.

```python
class Parent:
    def __init__(self):
        self.items = []

    def add_item(self, value):
        self.items.append(value)

class Child(Parent):
    def add_item(self, value):
        if not isinstance(value, int):
            raise ValueError("Child only accepts integers")
        super().add_item(value)
```
위 코드에서 `Child` 클래스의 `add_item()`은 부모 클래스의 `add_item()`을 의존한다. 만약 부모 클래스의 `add_item()`의 구현이 수정되면, 자식 클래스의 구현에 직접적인 영향을 미친다.

상속 구조가 깊어질수록, 시스템의 한 부분을 고칠 때마다
도미노처럼 예기치 않은 버그가 발생하는 이유가 바로 여기에 있다.

가장 최악은 부모클래스가 제대로 설계되지 않았을 때 벌어진다.
부모클래스의 구조적 결함을 추후에 발견할 시에 자식 클래스들에게 엄청나게 높은 비용을 청구한다.

#### 숨겨진 상태: 버그의 온상

상속의 더 근본적인 문제는 상태(state)의 경계가 흐려진다는 것이다.
부모의 멤버 변수를 자식이 암묵적으로 공유하게 되면,
객체의 일관성(invariant)은 더 이상 한 클래스 단위로 유지되지 않는다.

```python
class Base:
    def __init__(self):
        self.count = 0

    def increase(self):
        self.count += 1

class Sub(Base):
    def decrease(self):
        self.count -= 1  # Base 내부 상태를 직접 조작

obj = Sub()
obj.increase()
obj.decrease()
print(obj.count)  # 0 (정상처럼 보이지만, 제어권은 이미 사라졌다)
```

이 예제에서 Sub는 Base의 상태를 직접 변경한다.
Base는 자신의 상태 변화 경로를 완전히 통제하지 못하며,
이로 인해 상태 불안정성이 상속 구조 전체로 전파된다.

> 상속은 객체의 캡슐화를 깨뜨린다. 부모와 자식이 같은 상태를 공유하는 순간, 그 객체의 “경계”는 사라진다.

#### 상속대신 조합: 결합도는 낮추고 응집도는 올리고

상속의 장점으로 흔히 “코드 재사용”이 언급되지만,
그 목적이라면 조합(Composition) 으로 훨씬 안전하게 달성할 수 있다.

조합은 객체 간 관계를 명시적이고 유연하게 정의하며,
상태를 분리하고 책임을 분명히 나눌 수 있다.

```python
class ListHandler:
    def __init__(self):
        self.items = []

    def add(self, value):
        self.items.append(value)

class SafeList:
    def __init__(self):
        self.handler = ListHandler()

    def add(self, value):
        if not isinstance(value, int):
            raise ValueError("Only integers allowed")
        self.handler.add(value)
```
여기서 SafeList는 내부적으로 ListHandler를 “사용”하지만,
둘의 상태는 완전히 분리되어 있다.
ListHandler의 변경이 SafeList의 일관성을 깨뜨리지 않으며,
각 클래스는 자신의 상태를 스스로 책임진다.

객체지향의 본질이 ‘상태의 안정성’ 이라면,
좋은 설계는 상속이 아니라 경계를 유지하는 구조에서 시작된다.

다음 챕터는 경계와 계약에 대한 방법론이다.

---

## 객체지향의 본질 Chapter2: 계약

소프트웨어에서 말하는 **계약(Contract)**은
모듈 간, 혹은 **호출자(caller)**와 피호출자(callee) 사이에서 반드시 지켜야 하는 일련의 약속을 뜻한다.

이 관계는 흔히 **경계(boundary)**라고 부른다.
경계는 정보가 오가는 지점이며, 동시에 시스템에서 가장 ‘뜨겁고(hot)’ 위험한 곳이다.
여기서 타입 불일치, null 처리 미흡, 예외 처리 누락 같은 오류가 대개 발생한다.
즉, 모든 런타임 버그의 80%는 경계에서 발생한다고 해도 과언이 아니다.

### 경계의 필요성

런타임 버그를 최대한 없애겠다고 모든 경계구간을 제거한 후 모든 실행흐름을 한군데 - 예를 들면 하나의 굉장히 큰 메가함수 에 넣는 방식 - 은 어떨까?

표면적으로는 "경계가 없으니 오류가 덜 나겟네?" 라고 생각을 할 수 있지만 실제로는 다음과 같은 단점이 있다.

- 코드가 거대해진다.
- 가독성은 사라지며
- 테스트는 거의 불가능해지고
- 한 곳에서 발생한 변경이 전체 시스템으로 번지는 **연쇄 폭발(chain reaction)**이 일어난다.

따라서 경계구간은 가독성과 모듈화를 위해 반드시 존재해야하만 하며, 경계에 대한 명확성은 예측가능성, 테스트가능성, 버그재발율을 낮춘다.

### 경계는 반드시 계약을 수반한다.

경계는 자연스럽게 약속을 요구한다.
어떤 인자를 받고 어떤 값을 반환하며, 이름은 무엇인지는 참여자 모두가 알아야한다.

이 약속이 바로 **계약(Contract)**이다.

- 요청자는 정상적인 입력을 넘겨야 하고
- 피호출자는 명세된 출력과 동작을 보장해야 한다

이 약속이 지켜지지 않는다면, 해당 경계는 반드시 잠재적 버그 유발지역이 된다. 좋은 소프트웨어는 이 계약을 코드의 모든 경계에서 충실히 지키는 것에서 출발한다.
특히, 4기둥중 하나인 다형성은 경계와 계약에 대한 이해가 없이는 성립할 수도 조차 없다.

### 계약의 시작: **함수 시그니처(Signature)**부터

계약이 가장 먼저 등장하는 지점은 함수 시그니처다.
함수는 소프트웨어 구성 요소 중 가장 작은 단위의 계약이며, 호출자와 피호출자 사이에서 지켜야 할 약속을 가장 명확히 드러낸다.

```python
def divide(left: float, right: float) -> float: …
```
이 짧은 한 줄이 사실은 **작은 계약 문서(Contract Document)**를 의미한다.
여기에는 다음과 같은 명세가 암묵적으로 포함되어 있다.

### 호출자의 계약(Caller’s Contract)

호출자는 다음을 반드시 준수해야 한다.

1. 파라미터 개수 준수
- 정확히 2개의 인자를 전달해야 한다.

2. 타입 준수

- `left: float`, `right: float`, `int/str/list` 같은 타입을 넣으면 계약 위반이다.

3. 예외 조건 준수: 
- 함수가 “0으로 나눌 수 없다”는 예외를 명시한다면
호출자는 right ≠ 0이라는 조건을 반드시 지켜야 한다.


즉, 호출자는 “올바른 입력을 제공한다”는 계약 의무를 가진다.


### 피호출자(Callee’s Contract)

피호출자는 다음을 보장해야 한다.

1. 반환 타입 준수
- 결과는 반드시 float이어야 한다.

2. 예외 처리 또는 명세 제공
- DivisionByZero 가능성 존재
- 직접 에러를 발생시키거나, 대체 값을 반환하거나, 문서화하여 호출자가 계약을 인지하도록 해야 한다.

3. 일관된 동작(Deterministic Behavior)
- 동일한 입력 → 동일한 결과
- 숨겨진 상태 변경(side effects)이 없어야 한다.


### 클래스 맥락에서의 계약: 불변조건(Invariant)

divide가 클래스의 멤버라면, 계약은 함수 시그니처를 넘어
클래스의 불변조건까지 확장된다.

```python
class Operator:
    precision: int

    def divide(self, left: float, right: float) -> float:
        ...
```
여기서 지켜야 할 불변조건:
- precision은 음수가 될 수 없다
- 계산 도중 precision 값이 임의로 변경되어서는 안 된다
- 클래스 내부 상태는 함수 호출로 인해 망가져서는 안 된다

즉, 객체지향의 함수는 단순 “입력-출력 계약”을 넘어
객체 내부의 안정성까지 보장해야 한다.

---

## 객체지향의 본질 Chapter3: 인터페이스와 다형성 – 행동(Behavior)의 계약

여기까지의 이야기를 정리하면, 객체지향의 출발점은 **상태의 일관성**이고,  
모듈 사이의 안정적인 협력은 **계약(Contract)**에서 비롯된다.

이제 한 단계 더 올라가 보자.  
“함수 하나” 수준의 계약을 넘어서, **타입 전체가 어떤 행동을 보장해야 하는지**를 정의하는 단계가 있다.  
이것이 바로 **인터페이스(Interface)**다.

### 1. 인터페이스는 “행동의 최소 계약”이다

함수 시그니처가 **단일 함수에 대한 계약**이라면,  
인터페이스는 **어떤 타입이 제공해야 하는 행동(Behavior)의 묶음에 대한 최소 계약**이다.

인터페이스는 보통 이런 질문에 답한다.

- “이 타입은 무엇을 할 수 있어야 하는가?”  
- “어떤 메서드를 어떤 방식으로 제공해야 하는가?”  
- “호출자는 무엇을 기대해도 되는가?”

여기서 중요한 포인트는 두 가지다.

1. **인터페이스는 ‘무엇을 하는지’를 정의한다.**  
2. **‘어떻게 하는지’와 ‘어떤 상태를 가지는지’는 구현체의 몫이다.**

즉, 인터페이스는 행동을 약속하고,  
상태와 알고리즘은 숨긴다.

---

### 2. 인터페이스는 절대 내부 상태에 의존해서는 안 된다

인터페이스가 위험해지는 순간은 명확하다.

> “이 인터페이스를 구현하려면,  
> 반드시 이런 필드와 이런 내부 상태를 가져야 합니다.”

라고 말하기 시작할 때다.

이 말은 곧,

- 구현체에게 **특정 상태 구조를 강제**하고  
- 인터페이스가 **행동이 아니라 내부 구조를 설계**하기 시작한다는 뜻이다.

그 결과:

- 서로 다른 구현체가 **서로 다른 전략, 자료구조, 저장소**를 선택할 자유를 잃는다.  
- 인터페이스가 바뀌면, 그 밑에 매달린 모든 구현체가 동시에 흔들린다.  
- 다형성은 “같은 계약을 따르는 다양한 구현”이 아니라  
  “같은 틀에 갇힌 복제 객체”들로 축소된다.

객체지향에서 인터페이스는 이렇게 정의해야 한다.

- “이 메서드를 호출하면, 이런 일이 일어나야 한다.”  
- “이런 인자를 받고, 이런 결과를 보장해야 한다.”  
- “이런 예외 상황에서 어떻게 반응해야 한다.”

그러나 절대 이렇게 정의해서는 안 된다.

- “이 필드를 반드시 가지고 있어야 한다.”  
- “내부에 리스트 하나를 반드시 두고 그걸 직접 조작해야 한다.”  
- “이 순서대로 내부 상태를 바꿔야 한다.”

> 인터페이스는 **행동의 문서**여야지,  
> 구현체의 **내부 도면**이 되어서는 안 된다.

### 3. 행동 중심 인터페이스 설계의 기준

행동 중심 인터페이스는 다음 네 가지를 분명히 한다.

1. **무엇을 할 수 있는가 (행동의 이름과 목적)**  
   - 예: “이 인터페이스를 구현하는 모든 타입은 `divide`라는 연산을 제공해야 한다.”

2. **입력과 출력의 규격**  
   - 어떤 인자를 받고, 어떤 타입을 반환해야 하는지  
   - 잘못된 입력에 대해 어떤 반응을 하는지

3. **예외와 오류 처리의 규칙**  
   - 무엇을 예외로 볼 것인지  
   - 호출자가 미리 대비해야 할 상황은 무엇인지

4. **불변의 기대값**  
   - 동일한 입력에 대해 일관된 결과를 제공하는지  
   - 숨겨진 부작용 없이 동작하는지

반대로, 인터페이스가 **절대 가져서는 안 되는 것들**은 다음과 같다.

- 특정 필드나 멤버 변수의 존재를 전제로 하는 설명  
- “이 내부 리스트를 이렇게 조작하라” 같은 내부 구현 지시  
- 특정 데이터 구조나 저장 방식(예: “반드시 배열로 저장해야 한다”)에 대한 요구  
- 상태 라이프사이클(생성–변경–파괴)을 강제하는 상세 규칙

행동 중심 인터페이스는 다음 한 줄로 요약된다.

> **“무슨 행동을 해야 하는지”만 말하고,  
> “어떻게, 어떤 상태로 할지는 구현체에게 맡겨라.**


### 4. 다형성은 “같은 계약, 다른 구현”에서 탄생한다

다형성은 종종 이렇게 설명된다.

> “같은 메서드 이름을 가지고, 각자 다르게 동작한다.”

하지만 이 설명은 절반만 맞다.  
진짜 중요한 건 메서드 이름이 아니라 **“같은 계약”**이다.

- 호출자는 인터페이스가 정의한 **행동의 계약**만 알고 있고  
- 구현체는 그 계약을 **각자의 방식으로 충실히 이행**한다.

예를 들어, 백엔드에서 프론트에게 HTTP 결과를 반환하는 Response DTO가 지켜야하는 인터페이스를 다음과 같이 정의한다 하자.

```python
import abc
import typing as t
from pydantic import BaseModel


class IResponse(BaseModel, abc.ABC):
    @abc.abstractmethod
    def mock(self) -> t.Self:
        """ 가짜 데이터를 생성합니다.
        
        Returns:
            t.Self: 가짜 데이터가 채워진 응답 객체
        
        """
        pass

```
- 어떤 구현체는 **테스트용 더미 데이터**를 만들어 낼 수 있고  
- 다른 구현체는 **스펙에 맞는 기본값**을 구성할 수 있고  
- 또 다른 구현체는 **외부 설정을 참고한 기본 응답**을 만들 수 있다

호출자는 이 구현체들이 어떤 상태를 가지고 있는지 몰라도 된다.  
심지어:

- 메모리를 쓰는지,  
- 데이터베이스를 조회하는지,  
- 캐시를 사용하는지조차 알 필요가 없다.

호출자가 믿는 것은 오직 하나다.

> “이 타입이 이 인터페이스를 구현했다면,  
> `mock()`을 호출했을 때 유효한 응답을 돌려줄 것이다.”

이 믿음을 가능하게 만드는 것이 **행동 중심 인터페이스**이고,  
이 믿음을 바탕으로 동작하는 것이 바로 **다형성**이다.


### 5. 정리: 행동을 드러내고, 상태를 숨겨라

지금까지의 내용을 한 문장으로 압축하면 다음과 같다.

> **인터페이스는 행동의 계약을 정의하고,  
> 상태는 구현체 안에 캡슐화된다.**

이 원칙 하나가 다음을 동시에 보장한다.

- 다양한 구현체가 공존할 수 있는 **다형성**  
- 구현 변경에도 버티는 **유연한 설계**  
- 테스트 더블을 쉽게 만들 수 있는 **테스트 가능성**  
- 모듈 간 경계를 깔끔하게 유지하는 **캡슐화**

객체지향을 다시 정의하자면 이렇게 말할 수 있다.

> “좋은 객체지향 설계란,  
> **상태는 안으로 모으고, 계약과 행동만 밖으로 내보내는 기술**이다.”


## 객체지향의 본질 Chapter3: 의존방향