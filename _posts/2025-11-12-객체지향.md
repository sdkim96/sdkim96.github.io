---
layout: post
title: "객체지향"
date:   2025-07-05 17:51:00 +0900
categories: [blog, GitHub]
---

## 잘못된 객체지향: 버그의 온상

많은 객체지향 입문서와 강의는 캡슐화, 상속, 다형성, 추상화 같은 네 가지 원칙과 SOLID 원칙을 중심축으로 설명한다.
그러나 처음 이를 접하는 사람들에게—특히 클래스의 역할조차 명확히 이해하지 못한 상태에서는—이 원칙들은 너무 추상적이다.
‘좋은 설계 원칙’이라는데, 막상 코드에 적용하려면 Animal–Cat 예시 이상의 감이 잡히지 않는다.

나 또한 그랬다. 한때는 SOLID 다섯 글자를 외우며 “디자인 패턴을 모르면 좋은 프로그래머가 될 수 없다”고 믿었다.
하지만 원칙을 억지로 끼워 맞추던 시절엔, 기준이 모호하고 방향을 잡기 어려웠다.
‘교과서에 적혀 있으니 이렇게 써야 하나?’ 하며 어딘가 안 맞는 퍼즐을 억지로 끼워 넣듯 코드를 짜곤 했다.

실무에 처음 객체지향을 적용했을 때는 더 막막했다.
“상속은 왜 필요한가?”, “이 구조에서 캡슐화는 무슨 의미인가?”—단 하나의 함수조차 설계하기 어려운데, 클래스를 잘 설계할 리가 없었다.
결국 만들어진 것은 ‘누더기 골렘’ 같은 코드베이스였다.
한 곳을 고치면 다른 곳이 깨지고, 익셉션은 꼬리에 꼬리를 물었다.
버그의 근원은 문법이 아니라 **‘객체의 상태를 이해하지 못한 채 구조만 모방한 객체지향’**이었다.

## 객체지향의 본질 Chapter1: 상태

여러 시행착오 끝에, 나는 근본적인 질문으로 돌아갔다.
“객체지향이란 도대체 무엇인가?”

놀랍게도 답은 클래스조차 존재하지 않는 언어들—C와 Go에서 찾아졌다.
이 두 언어는 오직 데이터(struct) 와 그 데이터를 다루는 함수(function) 로 모든 기능을 구성한다.
즉, 데이터와 그 변화를 다루는 행위, 그것이 객체지향의 본질이라는 점이 드러났다.

C 레벨로 내려가면 클래스와 구조체의 차이는 거의 없다.
구조체에 함수 포인터를 추가하면 그것이 바로 메서드이며, 결국 **class란 ‘데이터 + 그 데이터를 다루는 함수의 묶음’**일 뿐이다.
CPU 입장에서는 둘 다 동일한 메모리 구조를 가진다.

이 관점에서 보면 객체지향의 핵심은 “상속”도 “캡슐화”도 아닌, **‘멤버변수들의 상태를 어떻게 일관성 있게 유지하느냐’**다.
모든 클래스는 일정한 초기 상태를 정의해야 하며, 그 상태의 변화를 명시적이고 예측 가능한 방식으로 관리해야 한다.
그것이 객체의 책임이자, 객체지향의 출발점이다.

### 상태의 불안정성

잘못 관리되는 상태는 본질적으로 불안정하다.
객체가 불안정하다는 것은 곧 그 내부 데이터가 신뢰할 수 없다는 것이며,
이는 단일 객체의 문제에 그치지 않고 시스템 전체의 버그로 확산된다.

객체의 상태는 프로그램이 실행되는 동안 수많은 연산과 상호작용을 거친다.
그 과정에서 한 번이라도 의도하지 않은 값이나 모호한 타입이 들어가면,
그 객체는 더 이상 “예측 가능한 동작”을 하지 못한다.
이때부터 모든 계산, 모든 로직은 불확실성 위에 서 있게 된다.

관리되지 않은 상태는 다음과 같은 경우를 의미한다.
- 객체가 유효하지 않은 초기 상태를 가질 때
- 멤버 변수의 타입이 일관되지 않을 때
- 외부에서 명시적이지 않은 방식으로 내부 값을 조작할 때

#### 유효하지 않은 초기값을 경계하라.

객체는 반드시 그 생성시점이 제일 중요하다.
이 시점부터 그 객체의 불안정성이 결정된다.

```python

# 유효하지 않은 초기값을 허용하는 클래스
class BadClass:
    def __init__(self, foo, bar) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    b = BadClass(1, 2)                      # 비정상, 타입 불일치

```
이 클래스는 한눈에 보기엔 단순하지만, 객체의 “의미적 상태”가 완전히 무너져 있다.
a와 b는 동일한 클래스에서 생성되었지만, 전혀 다른 타입을 가진다.
get_foo_length()를 호출하면 a는 정상 동작하지만 b는 TypeError를 발생시킨다.
즉, 같은 클래스의 인스턴스가 동일한 연산에 대해 일관된 결과를 보장하지 못하는 상태, 이것이 바로 **‘불안정한 객체’**다.

> 객체의 초기화 시점에 유효한 검증이 없다면, 클래스 설계는 실패한 것이다.

#### 멤버 변수의 타입은 생애주기 전체에서 일관되어야 한다.

안정적인 객체는 반드시 그 소멸까지 동일한 타입을 유지해야한다.
```python

# 유효하지 않은 초기값을 허용하는 클래스
class BadClass:
    def __init__(self, foo: str, bar: str) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

    def set_foo(self, v):
        self.foo = v

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    a.set_foo(4)                            # 타입 변경
    a.get_foo_length()                      # TypeError 발생

```
이 코드는 초기에는 문제가 없어 보이지만,
set_foo()에서 타입 일관성이 깨지면서 런타임 버그가 발생한다.

이 문제는 파이썬처럼 동적 타입 언어에서 특히 흔하다.
프로그램은 실행 중에 수없이 많은 곳에서 set_foo()를 호출할 수 있고,
그중 단 한 번만 타입이 잘못 들어가도 객체 전체가 오염된다.

#### 명시적인 인터페이스를 통해서만 상태를 조작하라.

가장 흔하지만 치명적인 버그유발점은 직접 속성 접근이다.
```python
class BadClass:
    def __init__(self, foo: str, bar: str) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    a.foo = 4
    a.get_foo_length() # 버그 발생
```
파이썬에서는 이런 직접 접근을 “간단하고 직관적이다” 라고 여길 수 있다.
하지만 이는 곧 객체의 내부 계약을 깨뜨리는 위험한 행위다.
외부에서 임의로 값을 변경하면, 클래스 내부에서 정의한 모든 전제가 깨진다.

이 문제를 해결하려면,
모든 상태 변경은 반드시 명시적 인터페이스(Setter 메서드) 를 통해 이뤄져야 한다.

> “캡슐화(Encapsulation)”란 데이터를 숨기는 것이 아니라, 데이터 변경 경로를 통제하는 것이다.

### 상속의 숨겨진 위험

객체지향을 처음 배울 때, 그 세 번째 기둥으로 강조되는 개념이 바로 상속(Inheritance) 이다.
“기존 코드를 재활용할 수 있다”는 약속은 달콤하게 들리지만,
실제 현업에서는 이 단어만큼 많은 시스템을 병들게 한 개념도 드물다.
상속은 잘못 사용되면 결합도(coupling) 를 폭발적으로 높이고,
객체의 상태를 통제 불가능하게 만든다.

#### 강한 결합도의 함정

상속은 단순한 코드 재사용 메커니즘이 아니다.
상속은 부모 클래스의 구현 세부사항을 자식이 전적으로 신뢰한다는 의미이며,
이는 곧 부모의 모든 변경이 자식에게 직접적인 영향을 미친다는 뜻이다.

```python
class Parent:
    def __init__(self):
        self.items = []

    def add_item(self, value):
        self.items.append(value)

class Child(Parent):
    def add_item(self, value):
        if not isinstance(value, int):
            raise ValueError("Child only accepts integers")
        super().add_item(value)
```
위 코드에서 `Child` 클래스의 `add_item()`은 부모 클래스의 `add_item()`을 의존한다. 만약 부모 클래스의 `add_item()`의 구현이 수정되면, 자식 클래스의 구현에 직접적인 영향을 미친다.

상속 구조가 깊어질수록, 시스템의 한 부분을 고칠 때마다
도미노처럼 예기치 않은 버그가 발생하는 이유가 바로 여기에 있다.

가장 최악은 부모클래스가 제대로 설계되지 않았을 때 벌어진다.
부모클래스의 구조적 결함을 추후에 발견할 시에 자식 클래스들에게 엄청나게 높은 비용을 청구한다.

#### 숨겨진 상태: 버그의 온상

상속의 더 근본적인 문제는 상태(state)의 경계가 흐려진다는 것이다.
부모의 멤버 변수를 자식이 암묵적으로 공유하게 되면,
객체의 일관성(invariant)은 더 이상 한 클래스 단위로 유지되지 않는다.

```python
class Base:
    def __init__(self):
        self.count = 0

    def increase(self):
        self.count += 1

class Sub(Base):
    def decrease(self):
        self.count -= 1  # Base 내부 상태를 직접 조작

obj = Sub()
obj.increase()
obj.decrease()
print(obj.count)  # 0 (정상처럼 보이지만, 제어권은 이미 사라졌다)
```

이 예제에서 Sub는 Base의 상태를 직접 변경한다.
Base는 자신의 상태 변화 경로를 완전히 통제하지 못하며,
이로 인해 상태 불안정성이 상속 구조 전체로 전파된다.

> 상속은 객체의 캡슐화를 깨뜨린다. 부모와 자식이 같은 상태를 공유하는 순간, 그 객체의 “경계”는 사라진다.

#### 상속대신 조합: 결합도는 낮추고 응집도는 올리고

상속의 장점으로 흔히 “코드 재사용”이 언급되지만,
그 목적이라면 조합(Composition) 으로 훨씬 안전하게 달성할 수 있다.

조합은 객체 간 관계를 명시적이고 유연하게 정의하며,
상태를 분리하고 책임을 분명히 나눌 수 있다.

```python
class ListHandler:
    def __init__(self):
        self.items = []

    def add(self, value):
        self.items.append(value)

class SafeList:
    def __init__(self):
        self.handler = ListHandler()

    def add(self, value):
        if not isinstance(value, int):
            raise ValueError("Only integers allowed")
        self.handler.add(value)
```
여기서 SafeList는 내부적으로 ListHandler를 “사용”하지만,
둘의 상태는 완전히 분리되어 있다.
ListHandler의 변경이 SafeList의 일관성을 깨뜨리지 않으며,
각 클래스는 자신의 상태를 스스로 책임진다.

객체지향의 본질이 ‘상태의 안정성’ 이라면,
좋은 설계는 상속이 아니라 경계를 유지하는 구조에서 시작된다.

다음 챕터는 경계와 계약에 대한 방법론이다.

## 객체지향의 본질 Chapter2: 계약
## 객체지향의 본질 Chapter3: 의존방향