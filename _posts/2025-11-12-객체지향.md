---
layout: post
title: "객체지향"
date:   2025-11-12 17:51:00 +0900
categories: [blog, GitHub]
---

## 잘못된 객체지향: 버그의 온상

많은 객체지향 입문서와 강의는 캡슐화, 상속, 다형성, 추상화 같은 네 가지 원칙과 SOLID 원칙을 중심축으로 설명한다.
그러나 처음 이를 접하는 사람들에게—특히 클래스의 역할조차 명확히 이해하지 못한 상태에서는—이 원칙들은 너무 추상적이다.
‘좋은 설계 원칙’이라는데, 막상 코드에 적용하려면 Animal–Cat 예시 이상의 감이 잡히지 않는다.

나 또한 그랬다. 한때는 SOLID 다섯 글자를 외우며 “디자인 패턴을 모르면 좋은 프로그래머가 될 수 없다”고 믿었다.
하지만 원칙을 억지로 끼워 맞추던 시절엔, 기준이 모호하고 방향을 잡기 어려웠다.
‘교과서에 적혀 있으니 이렇게 써야 하나?’ 하며 어딘가 안 맞는 퍼즐을 억지로 끼워 넣듯 코드를 짜곤 했다.

실무에 처음 객체지향을 적용했을 때는 더 막막했다.
“상속은 왜 필요한가?”, “이 구조에서 캡슐화는 무슨 의미인가?”—단 하나의 함수조차 설계하기 어려운데, 클래스를 잘 설계할 리가 없었다.
결국 만들어진 것은 ‘누더기 골렘’ 같은 코드베이스였다.
한 곳을 고치면 다른 곳이 깨지고, 익셉션은 꼬리에 꼬리를 물었다.
버그의 근원은 문법이 아니라 **‘객체의 상태를 이해하지 못한 채 구조만 모방한 객체지향’**이었다.

## 객체지향의 본질 Chapter1: 상태

여러 시행착오 끝에, 나는 근본적인 질문으로 돌아갔다.
“객체지향이란 도대체 무엇인가?”

놀랍게도 답은 클래스조차 존재하지 않는 언어들—C와 Go에서 찾아졌다.
이 두 언어는 오직 데이터(struct) 와 그 데이터를 다루는 함수(function) 로 모든 기능을 구성한다.
즉, 데이터와 그 변화를 다루는 행위, 그것이 객체지향의 본질이라는 점이 드러났다.

C 레벨로 내려가면 클래스와 구조체의 차이는 거의 없다.
구조체에 함수 포인터를 추가하면 그것이 바로 메서드이며, 결국 **class란 ‘데이터 + 그 데이터를 다루는 함수의 묶음’**일 뿐이다.
CPU 입장에서는 둘 다 동일한 메모리 구조를 가진다.

이 관점에서 보면 객체지향의 핵심은 “상속”도 “캡슐화”도 아닌, **‘멤버변수들의 상태를 어떻게 일관성 있게 유지하느냐’**다.
모든 클래스는 일정한 초기 상태를 정의해야 하며, 그 상태의 변화를 명시적이고 예측 가능한 방식으로 관리해야 한다.
그것이 객체의 책임이자, 객체지향의 출발점이다.

### 상태의 불안정성

잘못 관리되는 상태는 본질적으로 불안정하다.
객체가 불안정하다는 것은 곧 그 내부 데이터는 신뢰할 수 없다는 것이며,
이는 단일 객체의 문제에 그치지 않고 시스템 전체의 버그로 확산된다.

객체의 상태는 프로그램이 실행되는 동안 수많은 연산과 상호작용을 거친다.
그 과정에서 한 번이라도 의도하지 않은 값이나 모호한 타입이 들어가면,
그 객체는 더 이상 “예측 가능한 동작”을 하지 못한다.
이때부터 모든 계산, 모든 로직은 불확실성 위에 서 있게 된다.

관리되지 않은 상태는 다음과 같은 경우를 의미한다.
- 객체가 유효하지 않은 초기 상태를 가질 때
- 멤버 변수의 타입이 일관되지 않을 때
- 외부에서 명시적이지 않은 방식으로 내부 값을 조작할 때

#### 유효하지 않은 초기값을 경계하라.

객체는 반드시 그 생성시점이 제일 중요하다.
이 시점부터 그 객체의 불안정성이 결정된다.

```python

# 유효하지 않은 초기값을 허용하는 클래스
class BadClass:
    def __init__(self, foo, bar) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    b = BadClass(1, 2)                      # 비정상, 타입 불일치

```
이 클래스는 한눈에 보기엔 단순하지만, 객체의 “의미적 상태”가 완전히 무너져 있다.
a와 b는 동일한 클래스에서 생성되었지만, 전혀 다른 타입을 가진다.
get_foo_length()를 호출하면 a는 정상 동작하지만 b는 TypeError를 발생시킨다.
즉, 같은 클래스의 인스턴스가 동일한 연산에 대해 일관된 결과를 보장하지 못하는 상태, 이것이 바로 **‘불안정한 객체’**다.

혹은 다음과 같은 예시도 유효하지 않은 객체의 예시이다.
```python

# 객체를 생성하고 setter 호출함
class BadClass:
    def __init__(self, foo) -> None:
        self.foo = foo

    def set_bar(self, bar) -> None:
        self.bar = bar

if __name__ == "__main__":
    a = BadClass("foo_value")
    print(a.bar)                     # 에러 발생!
    a.set_bar("bar_value")
    print(a.bar)
```

위 예시는 a객체가 초기화 하는 시점엔 `bar` 는 초기화 되어있지 않다.
만약 `.set_bar()`의 호출 이전에 `bar`에 접근을 한다면, 해당 연산은 에러를 일으킬 것이다.
위 초기화 방법은 객체의 생애주기 전반에 대해서 같은 연산을 일관되게 보장하지 못한다.

> 객체의 초기화 시점에 유효한 검증이 없다면, 클래스 설계는 실패한 것이다.

#### 멤버 변수의 타입은 생애주기 전체에서 일관되어야 한다.

안정적인 객체는 반드시 그 소멸까지 동일한 타입을 유지해야한다.
```python

# 유효하지 않은 초기값을 허용하는 클래스
class BadClass:
    def __init__(self, foo: str, bar: str) -> None:
        self.foo = foo
        self.bar = bar

    def get_foo_length(self):
        return len(self.foo)

    def set_foo(self, v):
        self.foo = v

if __name__ == "__main__":
    a = BadClass("foo_value", "bar_value")  # 정상
    a.set_foo(4)                            # 타입 변경
    a.get_foo_length()                      # TypeError 발생

```
이 코드는 초기에는 문제가 없어 보이지만,
set_foo()에서 타입 일관성이 깨지면서 런타임 버그가 발생한다.

이 문제는 파이썬처럼 동적 타입 언어에서 특히 흔하다.
프로그램은 실행 중에 수없이 많은 곳에서 set_foo()를 호출할 수 있고,
그중 단 한 번만 타입이 잘못 들어가도 객체 전체가 오염된다.

#### 인터페이스를 통해서만 상태를 조작하라.

그 영향도에 비해 생각보다 위험성이 높은 작업은 항상 속성에 값을 update를 하는 작업이다.

```python
import enum

class StateEnum(enum.Enum):
    START=1
    PROCESSING=2
    END=3

class StateMachine:
    def __init__(self, id: str) -> None:
        self._id = id
        self._state = StateEnum.START

    def get_id(self) -> str:
        """ Get the ID of the state machine. """
        return self._id
    
    def get_state(self) -> StateEnum:
        """ Get the current state of the state machine. """
        return self._state
    
    def process(self) -> None:
        """ Process the state machine to the next state. """

        if self._state == StateEnum.START:
            self._state = StateEnum.PROCESSING
        elif self._state == StateEnum.PROCESSING:
            self._state = StateEnum.END

if __name__ == "__main__":
    machine = StateMachine("machine_1")  # 정상
    print(machine.get_id())              # 출력: machine_1
    machine.process()                    # START -> PROCESSING
    machine.process()                    # PROCESSING -> END
    print(machine.get_state())           # 출력: StateEnum.END
```

위 예시는 특정 상태머신을 `.process()` 란 함수로 상태를 변화시키는 간단한 예시이다.
실제로 private로 선언되어 있는 `_state` 속성값은 반드시 `.process()` 호출에 의해서만 그 상태변경이 허용된다.

데이터에 대한 변경 경로를 하나의 함수로 통제하면 그 데이터의 상태변화를 쉽게 추적할 수 있고, 부적절한 상태변화를 원천적으로 차단할 수 있다.
위 예시가 pythonic한 방법은 아니지만 프로젝트 규모가 커지고 유지보수의 비용이 증가한다면 특정 개발자의 실수 - 부적절한 상태변화 - 를 원천 차단하는 것이 옳은 방법일 수도 있다.

### 상속의 숨겨진 위험

객체지향을 처음 배울 때, 그 세 번째 기둥으로 강조되는 개념이 바로 상속(Inheritance) 이다.
“기존 코드를 재활용할 수 있다”는 약속은 달콤하게 들리지만,
실제 현업에서는 이 단어만큼 많은 시스템을 병들게 한 개념도 드물다.
상속은 잘못 사용되면 결합도(coupling) 를 폭발적으로 높이고,
객체의 상태를 통제 불가능하게 만든다.

#### 강한 결합도의 함정

상속은 단순한 코드 재사용 메커니즘이 아니다.
상속은 부모 클래스의 구현 세부사항을 자식이 전적으로 신뢰한다는 의미이며,
이는 곧 부모의 모든 변경이 자식에게 직접적인 영향을 미친다는 뜻이다.

```python
class Parent:
    def __init__(self):
        self.items = []

    def add_item(self, value):
        self.items.append(value)

class Child(Parent):
    def add_item(self, value):
        if not isinstance(value, int):
            raise ValueError("Child only accepts integers")
        super().add_item(value)
```
위 코드에서 `Child` 클래스의 `add_item()`은 부모 클래스의 `add_item()`을 의존한다. 만약 부모 클래스의 `add_item()`의 구현이 수정되면, 자식 클래스의 구현에 직접적인 영향을 미친다.

상속 구조가 깊어질수록, 시스템의 한 부분을 고칠 때마다
도미노처럼 예기치 않은 버그가 발생하는 이유가 바로 여기에 있다.

가장 최악은 부모클래스가 제대로 설계되지 않았을 때 벌어진다.
부모클래스의 구조적 결함을 추후에 발견할 시에 자식 클래스들에게 엄청나게 높은 비용을 청구한다.

#### 숨겨진 상태: 버그의 온상

상속의 더 근본적인 문제는 상태(state)의 경계가 흐려진다는 것이다.
부모의 멤버 변수를 자식이 암묵적으로 공유하게 되면,
객체의 일관성(invariant)은 더 이상 한 클래스 단위로 유지되지 않는다.

```python
class Base:
    def __init__(self):
        self.count = 0

    def increase(self):
        self.count += 1

class Sub(Base):
    def decrease(self):
        self.count -= 1  # Base 내부 상태를 직접 조작

obj = Sub()
obj.increase()
obj.decrease()
print(obj.count)  # 0 (정상처럼 보이지만, 제어권은 이미 사라졌다)
```

이 예제에서 Sub는 Base의 상태를 직접 변경한다.
Base는 자신의 상태 변화 경로를 완전히 통제하지 못하며,
이로 인해 상태 불안정성이 상속 구조 전체로 전파된다.

> 상속은 객체의 캡슐화를 깨뜨린다. 부모와 자식이 같은 상태를 공유하는 순간, 그 객체의 “경계”는 사라진다.

#### 상속대신 조합: 결합도는 낮추고 응집도는 올리고

상속의 장점으로 흔히 “코드 재사용”이 언급되지만,
그 목적이라면 조합(Composition) 으로 훨씬 안전하게 달성할 수 있다.

조합은 객체 간 관계를 명시적이고 유연하게 정의하며,
상태를 분리하고 책임을 분명히 나눌 수 있다.

```python
class ListHandler:
    def __init__(self):
        self.items = []

    def add(self, value):
        self.items.append(value)

class SafeList:
    def __init__(self):
        self.handler = ListHandler()

    def add(self, value):
        if not isinstance(value, int):
            raise ValueError("Only integers allowed")
        self.handler.add(value)
```
여기서 SafeList는 내부적으로 ListHandler를 “사용”하지만,
둘의 상태는 완전히 분리되어 있다.
ListHandler의 변경이 SafeList의 일관성을 깨뜨리지 않으며,
각 클래스는 자신의 상태를 스스로 책임진다.

객체지향의 본질이 ‘상태의 안정성’ 이라면,
좋은 설계는 상속이 아니라 경계를 유지하는 구조에서 시작된다.

다음 챕터는 경계와 계약에 대한 방법론이다.

---

## 객체지향의 본질 Chapter2: 계약

소프트웨어에서 말하는 **계약(Contract)**은
모듈 간, 혹은 **호출자(caller)**와 피호출자(callee) 사이에서 반드시 지켜야 하는 일련의 약속을 뜻한다.

이 관계는 흔히 **경계(boundary)**라고 부른다.
경계는 정보가 오가는 지점이며, 동시에 시스템에서 가장 ‘뜨겁고(hot)’ 위험한 곳이다.
여기서 타입 불일치, null 처리 미흡, 예외 처리 누락 같은 오류가 대개 발생한다.
즉, 모든 런타임 버그의 80%는 경계에서 발생한다고 해도 과언이 아니다.

### 경계와 계약

런타임 버그를 최대한 없애겠다고 모든 경계구간을 제거한 후 모든 실행흐름을 한군데 - 예를 들면 하나의 굉장히 큰 메가함수 에 넣는 방식 - 은 어떨까?
표면적으로는 "경계가 없으니 오류가 덜 나겟네?" 라고 생각을 할 수 있지만 실제로 코드가 거대해지고, 가독성은 사라지며, 테스트가 힘들어지고, 한 곳에서의 변경이 같은 스코프의 다른 곳에 영향을 줄 수 있다.

따라서 경계구간은 가독성과 모듈화를 위해 반드시 존재해야하만 하며, 경계에 대한 명확성은 예측가능성, 테스트가능성, 버그재발율을 낮춘다.

경계는 자연스럽게 약속을 요구한다.
어떤 인자를 받고 어떤 값을 반환하며, 이름은 무엇인지는 참여자 모두가 알아야한다.

이 약속이 바로 **계약(Contract)**이다. 요청자는 정상적인 입력을 넘겨야 하고, 피호출자는 명세된 출력과 동작을 보장해야 한다

이 약속이 지켜지지 않는다면, 해당 경계는 반드시 잠재적 버그 유발지역이 된다. 좋은 소프트웨어는 이 계약을 코드의 모든 경계에서 충실히 지키는 것에서 출발한다.
특히, 4기둥중 하나인 다형성은 경계와 계약에 대한 이해가 없이는 성립할 수도 조차 없다.

### 계약의 시작: **함수 시그니처(Signature)**부터

계약이 가장 먼저 등장하는 지점은 함수 시그니처다.
함수는 소프트웨어 구성 요소 중 가장 작은 단위의 계약이며, 호출자와 피호출자 사이에서 지켜야 할 약속을 가장 명확히 드러낸다.

```python
def divide(left: float, right: float) -> float: …
```
이 짧은 한 줄이 사실은 **작은 계약 문서(Contract Document)**를 의미한다.
여기에는 다음과 같은 명세가 암묵적으로 포함되어 있다.

#### 호출자의 계약(Caller’s Contract)

호출자는 다음을 반드시 준수해야 한다.

1. **파라미터 개수 준수**
2. **타입 준수**
3. **예외 조건 준수**

즉, 호출자는 “올바른 입력을 제공한다”는 계약 의무를 가진다.


#### 피호출자(Callee’s Contract)

피호출자는 다음을 보장해야 한다.

1. **반환 타입 준수**
2. **예외 처리 또는 명세 제공**
3. **일관된 동작(Deterministic Behavior)**

즉, 피호출자는 "함수의 실행을 보장한다"는 계약 의무를 가진다.


#### 불변조건(Invariant)

divide가 클래스의 멤버라면, 계약은 함수 시그니처를 넘어
클래스의 불변조건까지 확장된다.

```python
class Operator:
    def __init__(self, name: str) -> None:
        self._name = name # 이름은 반드시 변하면 안됩니다.

    def divide(self, left: float, right: float) -> float:
        print(f"{self._name} 계산기 나눗셈 시작!")
        ...
```
해당 예시에서 `self.name`의 값은 해당 객체의 생명주기 동안 불변해야 한다.

즉, 객체지향의 함수는 단순 “입력-출력 계약”을 넘어
객체 내부의 안정성까지 보장해야 한다.

---

### 계약의 응용: 인터페이스-행동(Behavior)의 계약

여기까지의 이야기를 정리하면, 객체지향의 출발점은 **상태의 일관성**이고,  
모듈 사이의 안정적인 협력은 **계약(Contract)**에서 비롯된다.

이제 한 단계 더 올라가 보자.  
“함수 하나” 수준의 계약을 넘어서, **타입 전체가 어떤 행동을 보장해야 하는지**를 정의하는 단계가 있다.  
이것이 바로 **인터페이스(Interface)**다.

#### 인터페이스는 “행동의 최소 계약”이다

함수 시그니처가 **단일 함수에 대한 계약**이라면,  
인터페이스는 **어떤 타입이 제공해야 하는 행동(Behavior)의 묶음에 대한 최소 계약**이다.

1. **인터페이스는 ‘무엇을 하는지’를 정의한다.**  
2. **‘어떻게 하는지’와 ‘어떤 상태를 가지는지’는 구현체의 몫이다.**

즉, 인터페이스는 행동을 약속하고,  
상태와 알고리즘은 숨긴다.


#### 상태를 ‘강하게 강제하는’ 인터페이스는 위험하다.

상태를 가지는 인터페이스를 구현해야하는 구현체들은 그 상태를 반드시 멤버변수로 가지고 있어야한다.
이는 구현체에게 **특정 상태 구조를 강제**를 하는 것이고, **행동이 아니라 내부 구조를 설계**하기 시작한다는 뜻이다.

이를 구현해야하는 구현체는 **서로 다른 전략, 자료구조, 저장소**를 선택할 자유를 일부 잃는다.  
이는 객체지향의 4번째 기둥인 다형성의 정의: “같은 계약을 따르는 다양한 구현” 이 아니라 “같은 틀에 갇힌 복제 객체” 의 형태로 격하시킨다.

다만, 통신 응답처럼 도메인 자체가 특정 필드를 항상 가지는 경우(예: error)처럼, **“행동을 설명하기 위한 최소한의 상태”**는 포함될 수 있다.

```python
import abc
import typing as t
from pydantic import BaseModel, Field


class IResponse(BaseModel, abc.ABC):

    error: Exception | None = Field(None, exclude=True)
    """ 해당 인터페이스를 구현하는 응답 객체는 Optional한 오류정보를 포함해야합니다."""

    @property
    def is_success(self) -> bool:
        """ 응답이 성공했는지 여부를 반환합니다.
        
        Returns:
            bool: 오류가 없는 경우 True, 오류가 있는 경우 False
        
        """
        return self.error is None

    @classmethod
    @abc.abstractmethod
    def mock(cls) -> t.Self:
        ...
        """ 가짜 데이터를 생성합니다.
        
        Returns:
            t.Self: 가짜 데이터가 채워진 응답 객체
        
        """
        pass

```
해당 인터페이스는 특정 통신에 대한 결과를 정의한다. 모든 통신은 에러가 날 수 있고, 이는 Optional할 수 있기 때문에 error필드가 존재하는 건 타당하다.
즉 모든 인터페이스는 "행동중심"이 되야하고, 내부 상태를 가지는건 위험하지만, 특정 인터페이스에 따라 상태를 가질 수 있다.

> 인터페이스는 **행동의 문서**여야지, 구현체의 **내부 도면**이 되어서는 안 된다.

#### 행동 중심 인터페이스 설계의 기준

행동 중심 인터페이스는 다음 네 가지를 분명히 한다.

1. **무엇을 할 수 있는가 (행동의 이름과 목적)**  
2. **입력과 출력의 규격**  
3. **예외와 오류 처리의 규칙**  
4. **불변의 기대값**  

반대로, 인터페이스가 **절대 가져서는 안 되는 것들**은 다음과 같다.

1. **“이 내부 리스트를 이렇게 조작하라” 같은 내부 구현 지시**
2. **특정 데이터 구조나 저장 방식(예: “반드시 배열로 저장해야 한다”)에 대한 요구**  
3. **상태 라이프사이클(생성–변경–파괴)을 강제하는 상세 규칙**

행동 중심 인터페이스는 다음 한 줄로 요약된다.

> **“무슨 행동을 해야 하는지”만 말하고, “어떻게, 어떤 상태로 할지는 구현체에게 맡겨라.**

#### 정리: 행동을 드러내고, 상태를 숨겨라

지금까지의 내용을 한 문장으로 압축하면 다음과 같다.

> **인터페이스는 행동의 계약을 정의하고, 상태는 구현체 안에 캡슐화된다.**

이 원칙 하나가 다음을 동시에 보장한다.

- 다양한 구현체가 공존할 수 있는 **다형성**  
- 구현 변경에도 버티는 **유연한 설계**  
- 테스트 더블을 쉽게 만들 수 있는 **테스트 가능성**  
- 모듈 간 경계를 깔끔하게 유지하는 **캡슐화**

객체지향을 다시 정의하자면 이렇게 말할 수 있다.

> “좋은 객체지향 설계란, **상태는 안으로 모으고, 계약과 행동만 밖으로 내보내는 기술**이다.”

## 객체지향의 본질 Chapter3: 의존방향

앞에서 우리는 상태와 계약을 이야기했다.
이제 그 상태와 계약들이 서로 어떤 방향으로 기대고 있어야 하는가, 즉 **의존 방향(Dependency Direction)**을 이야기할 차례다.

간단히 말하면, 이 장에서 다루려는 핵심은 한 줄이다.

> 변하기 쉬운 코드가, 변하기 어려운 코드에 의존해야 한다. 그 반대는 재앙이다.

### 시스템의 분리: Presentation, Service, Infrastructure
복잡한 시스템을 다루기 위해 우리는 항상 “층(layer)”을 만든다.
이름은 다양하지만, 대부분 다음 세 가지로 정리할 수 있다.

1. **Presentation Layer**
해당 영역은 사용자가 직접 만나는 영역이다. 웹이라면 Controller, View, API 엔드포인트, CLI라면 main 함수, 터미널 입출력이 예시가 될 수 있다.

2. **Service (Domain) Layer**
해당 영역은 비즈니스 규칙과 도메인 로직이 존재한다. “이 시스템이 왜 존재하는가?”를 대답하는 부분이며 상태와 계약의 대부분이 여기에 존재한다.

3. **Infrastructure Layer**
해당 영역은 DB, 외부 API, 메시지 큐, 파일 시스템처럼 어플리케이션 외부(chaos)와 만나는 지점이다.

이 세 레이어는 단순히 “기분”으로 나누는 것이 아니다.
의존 방향이 반드시 한쪽으로만 흐르도록 하기 위해 나눈다.

일반적으로 다음 방향을 따라야 한다.
`Presentation → Service → Infrastructure 인터페이스 ← Infrastructure 구현`

예를 들어, Service Layer는 Infrastructure Layer의 특정 모듈을 의존한다.

### 위험을 고립시켜라: 예외처리의 고립화

의존 방향이 어긋날 때 가장 먼저 터지는 건 예외 처리다.
이런 것들은 대부분 Infrastructure에서 발생한다.
문제는, 이 예외들이 아무 생각 없이 Service와 Presentation까지 마구 튀어 올라올 때다.

이 위험을 가장 잘 관리할 수 있는 방법은 `Error as Value` 철학이다.

위험한 것(외부 의존)은 바깥에서 최대한 처리하고,
안쪽(Service, Domain)은 최대한 단순한 계약/상태에만 집중하게 만든다.

### 핫과 쿨: 핫은 쿨에 의존해야한다.

🔥 핫(Hot)
- 고객 요구에 따라 자주 바뀌는 코드
- 실험이 잦고, 제품 방향성에 따라 구조가 바뀌는 코드
- Presentation, Service Layer(특히 서비스 로직), UI, API 스펙, 기능 확장 등
- “제품 레벨의 뜨거운 변화가 집중되는 곳”

🧊 쿨(Cool)
- 비교적 안정적이며 잘 변하지 않는 코드
- 기술적 특성이 고정되고, 큰 변화가 거의 없는 계층
- DB 드라이버, HTTP 클라이언트, 로깅 시스템, 메시지 큐 어댑터 등
- “시스템이 rely하는 기술 기반들이 모여 있는 곳”

반드시 뜨거운 영역(핫)은 차가운 영역(쿨)이 제공하는 안정적인 기반 위에서 움직여야 한다.

단단하게 유지되고 에러핸들링이 탄탄한 Infrastructure Layer는 그 요구사항이 거의 변하지 않는다.
예를들어, 갑자기 잘 유지되고 있는 http모듈을 갑자기 grpc로 마이그레이션하는 결정은 거의 흔하지 않다.

쿨이 핫에 의존하게 되면 변화가 적어야 하고 안정적인 저수준을 유지해야하는 기술적 코드가 비지니스 로직에 따라 행동하고 구현 세부사항이 정해질 수 있다.