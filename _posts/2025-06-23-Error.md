---
layout: post
title:  "The Power of Error Handling"
date:   2025-06-24 20:30:00 +0900
categories: [블로그, GitHub]
---

# Everyone hates bugs.

Everyone hates bugs. A bunch of them not only distracts my focus, but also ruins our lifestyle.
I really hate working overtime just because I was careless.
Bugs can come from many sources such as **type mismatches** or **poor error handling**.

Today, I’ll focus on how to handle errors properly, so that I can liberate myself from the bug trap.

# Exception Handling
When I first learned about error handling, I believed that wrapping all my logic in a `try-catch` block was the essence of good error handling.
I saw countless examples with try-catch wrapping huge chunks of code.
Think of an API server, for example — it’s tempting to just wrap the entire handler like this:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def some_work():
    try:
        some_val_from_db = fetch_db()
        some_result = some_action(some_val_from_db)
        return {"result": some_result}
    except:
        raise HTTPException()

```
That’s the easiest way to handle errors. And yes — it works.
But just because it's **easy**, doesn't mean it's **good**. In fact, this is wrong and dangerous approach to build strong application.

Once I studied Clang, I recognize that there are no `try-catch` in C.  Everyone knows world’s most complicated and sophiscated system is linux, and basically, it is almost written in C. At that point, I wonder how linux and c written programs handle errors.


# Learning from C: Error as Value
Later, when I studied C, I discovered something enlightening:
There is no try-catch in C.

And yet - the world's most complex and robust system, Linux, is mostly written in C.

So I asked myself:
> How do C programs - and even linux itself  - handle errors?

The answer? It is so simple and easiest way to achieve.
> By returning error values.

Here is a classic example of C:
```c
#define ERROR -1

int some_func(int param)
{
    // If param is invalid, return -1 as an error code.
    if (param < 0){
        return ERROR;
    }

    // ... Do many things..

    return 0;

}
```
This idea is so simple and cool, And it turns out, the `Go` programming language inherits this philosophy.
```go

func divider(a int, b int) (float64, error) {

    if b == 0 {
        return 0.0, fmt.Error("divider can't be zero")
    }
    return float64(a) / float64(b), nil
    
}
```

# Designing Error Boundaries

One of the most outlooked, yet essential, parts of building successful application is explicitly defining where my responsiblities starts and end - especially when it comes to handle errors.
I like the word `taking responsiblity` when I write codes in my workspaces. By taking responsiblity of my codebase, I clearly define specs and logics of all functions and classes, relationships between modules, dependency direction, and even lintering across my codes. The word `responsible`, in the context of programming, is also **contract** between me and outside world.
When it comes to sophiscated system that has lots of layers, **contract** is the most important thing to build robust software. Caller should not know about inside logic of what it calls, just know what it returns and what it raises.

