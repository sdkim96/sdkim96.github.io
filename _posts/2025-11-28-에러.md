---
layout: post
title: "에러"
date:   2025-11-12 17:51:00 +0900
categories: [blog, GitHub]
---

## 에러가 나지않은 시스템?

**에러가 나지않은 시스템이 존재한다** 라는 명제를 과학적인 명제로 판단할 수 있을까?
과학적인 명제란 해당 명제가 반증가능해야하고, 관찰가능해야한다.

우리가 내세운 명제가 반증가능하려면, **세상에 있는 모든 시스템을 검사해서 ‘에러 없는 시스템이 단 하나도 없다’**는 것을 증명해야 한다.

하지만, 이건 실험적으로 원천불가능한 일이다.
- 과거에 존재했던 시스템
- 현재 존재하는 시스템
- 미래 존재하는 시스템 
- 이론적으로 만들어질 수 있는 모든 시스템

모두를 실험/관찰 할 수 없기 때문이다.

마치, **외계인은 존재한다**, **절대 오류가 없는 프로세스가 우주 어딘가에 존재한다.** 같은 명제를 반증해야하는건데, 이는 현실적으로 모든 시공간을 검사할 수 없기 때문에 반증이 불가능한 명제의 영역이다.

따라서 나는, **시스템은 에러가 존재한다** 라는 대전제 하에 진행하겠다.

## 에러의 두 종류 (내부 vs 외부)

하드웨어가 망가지는 극단적인 상황을 제외하면, 다음 코드는 대부분의 언어 스펙 하에선 에러가 날 수 없다.

```c
int a = 0;
a = a + 3;
```
하지만 아래 코드는 거의 동일한 코드지만 에러가 발생한다.
```java
String a = new String();
a = a + 3;
```
내부코드에서 발생하는 에러들의 대부분의 경우 타입 불일치나 잘못된 연산에 의한 사람의 실수로, 이는 컴파일 타임이나 정적 분석환경 하에서 대부분 잡을 수 있다. 
이것이 실제 어플리케이션 런타임까지 올라온다면 **설계의 실패** 나 **개발자의 실수** 로 간주될 수 있으며, 반드시 고쳐져야만 하고 대부분 그리 어렵지 않게 고칠 수 있다.

이와 반대로, 외부코드에서 발생하는 버그들은 대부분 
    - 네트워크
    - 외부 API
    - DB
    - 파일 시스템
    - 타임아웃, 리소스부족

같이, 개발자의 영역 밖에 존재한다. 이런 버그들은 반드시 **시스템 경계**에서 핸들링 되야하며, 우리 시스템을 망치지 않게 감시해야한다.

결론적으로 내부에러는 고쳐야만 하는 에러고 외부에러는 핸들링되야하는 에러다.

## 에러: 관측되야하고 재현가능해야한다.

그렇다면, 외부에서 발생한 에러들은 반드시 관측되야만 하고, 재현 가능해야한다. 기존 방식으론 관측까진 가능하지만, 재현한다는것은 생각하기 어렵다.

또한, 에러때문에 다른 정상적 객체들의 상태가 침해받아선 안되고, 정상적 흐름이 예측 불가능한 곳에서 전파되면 안된다.

다음 3가지 속성이 외부에서의 에러를 대할 때의 중요한 핵심 키워드들이다.

- 관측가능성
- 재현가능성
- 에러격리

## 핵심 아이디어: 에러는 값(Value) 이어야만 한다.

에러는 대부분의 언어에서 객체(Object) 혹은 구조체(Struct)로 표현될 수 있다.
그 말은 곧, 에러는 “값처럼” 다룰 수 있다는 뜻이고,
나는 이 점이 근본적으로 중요하다고 생각한다.

그렇다면 값으로 처리하는게 더 좋은 이유는 무엇일까?

### 1. 관측가능성

에러를 값으로 다루면 **에러가 어디서, 왜, 어떤 맥락에서 발생했는지를 객체 형태로 완전히 보존**할 수 있다.

사실 관측가능성은 기존 try-catch Exception방식으로 핸들링되도 충분히 가능한 방식이다. stdout출력에 기록되는 에러의 단말마 - 나는 터미널에 올라오는 Traceback을 이와 같이 표현하는 걸 좋아한다. - 는 그 자체만으로도 코드의 어떤 지점에서 에러가 발생했는지 충분히 알려준다. 

하지만, 객체 기반 에러는 발견되면 그것에 대해 에러의 이름, 에러의 성격, Traceback도 전략적으로 터미널에 출력하는 것이 가능하다.
예를 들어, 에러객체를 Serialize한다면 다음과같이 표현할 수 있다. 
```json
{
  "error_type": "TimeoutError",
  "endpoint": "https://api.example.com",
  "latency_ms": 5100,
  "request_id": "c32f-12a8",
  "timestamp": "2025-11-12T12:00:11Z"
}
```
해당 JSON은 DB에도 저장될 수 있는 구조고, 여러 관측프로그램에 전송가능한 형태다.
즉, 에러의 객체화는 구조화된 에러의 형태를 보존하고, 관측가능성을 올려준다.

### 2. 재현가능성

재현가능성은 “같은 환경에서 똑같은 에러를 다시 발생시킬 수 있는가?“다.

Exception 기반 시스템은 대부분 다음 문제가 있다:
- stack trace는 문자열 → 기계가 재현 불가
- 에러 context가 불완전 → 환경 복제 불가
- 입력/출력 로그가 없음 → 재현용 실험 데이터가 없음

반면 에러가 값이면 재현은 설계 문제의 영역이 된다.

```json
{
  "error_type": "BadRequest",
  "payload": { },
  "metadata": { },
  "step": "LLMTool.ParseOutput"
}
```
이 데이터를 DB에서 불러와 Deserialize를 한다면:
1. 같은 input 실행
2.	같은 상태에서
3.	같은 함수를 돌리면

→ 재현이 100% 가능해진다.

즉, “기록(serialized)” 가능하기 때문에 재현(deserialized)이 가능해진다.


### 3. 전파 방향 제어

### 4. 강제 핸들링

