---
layout: post
title: "에러"
date:   2025-11-12 17:51:00 +0900
categories: [blog, GitHub]
---

## 에러가 나지않은 시스템?

**에러가 나지않은 시스템이 존재한다** 라는 명제를 과학적인 명제로 판단할 수 있을까?
과학적인 명제란 해당 명제가 반증가능해야하고, 관찰가능해야한다.

우리가 내세운 명제가 반증가능하려면, **세상에 있는 모든 시스템을 검사해서 ‘에러 없는 시스템이 단 하나도 없다’**는 것을 증명해야 한다.

하지만, 이건 실험적으로 원천불가능한 일이다.
- 과거에 존재했던 시스템
- 현재 존재하는 시스템
- 미래 존재하는 시스템 
- 이론적으로 만들어질 수 있는 모든 시스템

모두를 실험/관찰 할 수 없기 때문이다.

마치, **외계인은 존재한다**, **절대 오류가 없는 프로세스가 우주 어딘가에 존재한다.** 같은 명제를 반증해야하는건데, 이는 현실적으로 모든 시공간을 검사할 수 없기 때문에 반증이 불가능한 명제의 영역이다.

해당 글은 **시스템은 에러가 존재한다.** 라는 대전제 하에 진행하겠다.

## 에러의 두 종류 (내부 vs 외부)

하드웨어가 망가지는 극단적인 상황을 제외하면, 다음 코드는 대부분의 언어 스펙 하에선 에러가 날 수 없다.

```c
int a = 0;
a = a + 3;
```
하지만 아래 코드는 거의 동일한 코드지만 에러가 발생한다.
```java
String a = new String();
a = a + 3;
```
내부코드에서 발생하는 에러들은 대부분의 경우 타입 불일치나 잘못된 연산에 의한 사람의 실수로 인해서 발생한다. 이는 컴파일 타임이나 정적 분석환경 하에서 대부분 잡을 수 있다. 
이런 오류들이 실제 어플리케이션 런타임까지 올라온다면 **설계의 실패** 나 **개발자의 실수** 로 간주될 수 있으며, 반드시 고쳐져야만 하고 대부분 그리 어렵지 않게 고칠 수 있다.

이와 반대로, 외부코드에서 발생하는 에러들은 개발과정에서 예측은 가능하나, 개발자가 버그에 대해 책임(수정과 패치에 대한 책임)은 지지 않는다. 따라서, 외부와 맞닿아 있는 지점들:
- 네트워크
- 외부 API
- DB
- 파일 시스템
- 타임아웃, 리소스부족

같은 영역들은 에러여부에 대해 반드시 **시스템 경계**에서 catch가 되어야 하며, 이 에러가 우리 시스템을 망치지 않게 감시되어야한다. 

## 에러: 관측되야하고 재현가능해야한다.

운영환경에 배포된 프로덕션급 제품들에 대해선 제공되는 API들에 대해선 그 품질적 기능보장이 되어야 한다. 100%의 기능성을 담보하기엔 대전제인 **시스템은 에러가 존재한다.** 와 충돌되기 때문에 99%의 기능성을 달성하는게 목표라고 한다면, 그 과정에서 해당 API들은 다음과 같은 과정을 거친다.

- 70%의 기능성을 달성하기엔 그렇게 어렵지 않다.
- 90%의 기능성을 달성하는건 0 -> 70 보다 더 어려운 과제다.
- 99%의 기능성을 달성하는건 70 -> 90 보다 더 어려운 과제다.

특정 threshold를 지날수록, 기능성을 담보 (에러와 버그를) 하는건 더욱 어려워지고, 에러들은 더욱 재현이 어렵다.
예를 들어, LLM API을 사용해 특정 비지니스 로직을 달성하는 시스템이 있다 해보자. 해당 시스템이 의존하는 LLM이 1%의 확률로 Request Error가 발생한다면, 이는 재현율이 굉장히 낮은 외부 에러고 이 에러를 잡기 위해선 이미 Traceback으로 깨져버린 로그파일이나 터미널에 출력되는 Stdout 출력밖에 존재하지 않는다.

운이 좋게 디버깅중에 그 Request Error를 잡았다 해보자. 하지만 이 에러의 근원을 판단하기 위해선 재현이 가능해야하는데 (한번의 운좋은 디버깅만으로 문제의 근원을 고칠 수 있다는 자신감은 버리자.) 해당 순간의 LLM Payload는 기록이 되있지도 않고, 여러 객체들의 상태는 산발적으로 퍼져있어 혼란스럽기만 하다.

해당 상황보다 더 치명적인 상황은, 비결정적으로 전파된 에러때문에 발생하는 특정 객체의 상태가 99%의 확률로 망가지는 경우다. 예를 들어, 엑셀파일을 읽어 5시간동안 데이터 객체의 생명주기를 유지하면서 일정 주기마다 엑셀 파일에 현재 상태를 쓰는 API가 있다 해보자.

> 특정 시점에 갑자기 특정 줄이 truncate 되버린 것이다! 

특히 이 경우는 비결정적인 에러전파로 인해 특정 시점에 객체의 상태가 망가지고, 그 객체를 DB나 파일같은 저장소에 쓸때 자주 발생한다. 

다음 4가지 키워드는 내가 중요하게 생각하는 에러에 대한 키워드들이다.

- 관측가능성
- 재현가능성
- 에러격리
- 결정적인 에러전파

## 핵심 아이디어: 에러는 값(Value) 이어야만 한다.

에러는 대부분의 언어에서 객체(Object) 혹은 구조체(Struct)로 표현될 수 있다.
그 말은 곧, 에러는 “값처럼” 다룰 수 있다는 뜻이고,
나는 이 점이 근본적으로 중요하다고 생각한다.

그렇다면 값으로 처리하는게 더 좋은 이유는 무엇일까?

### 1. 관측가능성

에러를 값으로 다루면 **에러가 어디서, 왜, 어떤 맥락에서 발생했는지를 객체 형태로 완전히 보존**할 수 있다.

사실 관측가능성은 기존 try-catch Exception방식으로 핸들링되도 충분히 가능한 방식이다. stdout출력에 기록되는 에러의 단말마 - 나는 터미널에 올라오는 Traceback을 이와 같이 표현하는 걸 좋아한다. - 는 그 자체만으로도 코드의 어떤 지점에서 에러가 발생했는지 충분히 알려준다. 

하지만, 객체 기반 에러는 발견되면 그것에 대해 에러의 이름, 에러의 성격, Traceback도 전략적으로 터미널에 출력하는 것이 가능하다.
예를 들어, 에러객체를 Serialize한다면 다음과같이 표현할 수 있다. 
```json
{
  "error_type": "TimeoutError",
  "endpoint": "https://api.example.com",
  "latency_ms": 5100,
  "request_id": "c32f-12a8",
  "timestamp": "2025-11-12T12:00:11Z"
}
```
해당 JSON은 DB에도 저장될 수 있는 구조고, 여러 관측프로그램에 전송가능한 형태다.
즉, 에러의 객체화는 구조화된 에러의 형태를 보존하고, 관측가능성을 올려준다.

### 2. 재현가능성

재현가능성은 “같은 환경에서 똑같은 에러를 다시 발생시킬 수 있는가?“다.

Exception 기반 시스템은 대부분 다음 문제가 있다:
- stack trace는 문자열 → 기계가 재현 불가
- 에러 context가 불완전 → 환경 복제 불가
- 입력/출력 로그가 없음 → 재현용 실험 데이터가 없음

반면 에러가 값이면 재현은 설계 문제의 영역이 된다.

```json
{
  "error_type": "BadRequest",
  "payload": { },
  "metadata": { },
  "step": "LLMTool.ParseOutput"
}
```
이 데이터를 DB에서 불러와 Deserialize를 한다면:
1. 같은 input 실행
2. 같은 상태에서
3. 같은 함수를 돌리면

→ 재현이 100% 가능해진다.

즉, “기록(serialized)” 가능하기 때문에 재현(deserialized)이 가능해진다.


### 3. 전파 방향 제어

### 4. 강제 핸들링

